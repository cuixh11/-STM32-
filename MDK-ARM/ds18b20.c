#include "ds18b20.h"


void yanshi_dq(uint32_t i)
{
	while(i--);
}


/********DS18B20初始化*********/
void int_ic(void)
{
			DQ(1);//为开始时主机拉低总线做准备
			yanshi_dq(120);//稍加延时使总线电平稳定
			DQ(0);//将总线拉低
			yanshi_dq(5900);//延时，参数与晶振频率有关，一般至少480微秒
			DQ(1);//主机释放总线
			yanshi_dq(360);//释放总线后延时，等待15~60微秒再检测总线是否被拉低
			while(read_ds18b20==1);//检测总线是否被拉低，即是否应答
			yanshi_dq(5900);
			DQ(1);
			yanshi_dq(360);
}


/********DS18B20读数据*******/
uchar read()//调用时返回读取的字节
{
static uchar a;
uchar i;
for(i=0;i<8;i++)//每次读一位
    {
			DQ(0);//以主机拉低总线至少1us开始读当前位
			yanshi_dq(30);//移位兼延时，第一次右移无作用
			DQ(1);//主机释放总线，使从机能够占用总线
			yanshi_dq(100);//延时
			if(read_ds18b20==1)//如果检测到1，或用“if(read_ds18b20）”。因为先进来的是最低位，将最低位放到最高位上，即放到0x80。
			{
				a=(a>>1)|0x80;//如果进来的是0，不会进行此操作
			}
			else
			{
				a=a>>1;
			}
			DQ(1);
			yanshi_dq(540);//延时。循环八次组成一个字节
	 }
	 return a;//将接收组装好的字节返回调用处
}


/**********DS18B20写数据*********/
void write(uint dat)
{
uchar i;//定义循环变量，局部变量
for(i=0;i<8;i++)//每次传送一位，一个字节是八位
  {
		
		DQ(0);//总线拉低
		yanshi_dq(55);//延时
		DQ(dat&0x01);//dat，按位与0x01（除了最低位，其他位都变为0），取送最低位兼延时。如果指令的最低位是1，那与完之后dq为1，反之。
		yanshi_dq(720);//延时，使从机有时间取该位
		DQ(1);//送完当前位后释放总线
		dat=dat>>1;//将指令右移一位，为送下一位做准备，再次循环。传送数据时低位在前，所以先送最低位
		yanshi_dq(55);
  }
}
 

/*********DS18B20操作读取温度********/
uchar caozuo()//将读温度这一个函数封装为caozuo
{
		  static uchar high,low;//启动温度转换
			int_ic();//初始化   
			write(0xcc);//跳过ROM操作，因为只有一个DS18B20测温，就不需要搜索ROM、读ROM以及匹配ROM等操作
			write(0x44);//启动rom转换
			yanshi_dq(330);//延时等待，让其有足够的时间转换完，330并不代表330微秒，而是与晶振频率等有关
	
			int_ic();//读温度，也是从初始化开始
			write(0xcc);//跳过ROM
			write(0xbe);//告诉它要开始读温度了
	
			low=read();//每八位一个字节，剩下low和high两个字节，最低位和次低位
			high=read();//将温度值读出来放到了low和high两个变量中
			high<<=4;//将温度整数组成一个字节，高字节左移4位
			high|=(low&0xf0)>>4;//0x1111 1010,1010 1011 
			return high;				//0x1010 0000,0000 1011
}													//0x1010 1011
